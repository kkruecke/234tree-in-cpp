#ifndef level_order_display_82394u9324
#define level_order_display_82394u9324

#include <string>

/* 
 *  "template design pattern" functor class for displaying tree23<Key, Value>::Node23 instances in level order. Its function call operator

    void operator()(const Tree::Node23& node)

   calls two virtual methods that derived classes override: 

     1. display_level(ostream& ostr, int level), which provides a default implementation.
     2. display_pair(ostream& ostr, const Tree::Node& node), which simply calls node.print(ostr).

   A default implementation is provided for display_level().

   The constructor takes two parameters: a const Tree& and  an ostream&. Its copy constructor queries and sets the height by calling tree.getHeight(). Is also sets/
   resets the input copy constructors input parameter's height. This acts like a sort of reset() method, when the functor is passed by value, that re-queries the
   tree's height. 
 * 
 */

class levelOrderDisplay  {

  private:
     int height;
     int current_level;

     std::ostream& ostr;
      
  public:
    levelOrderDisplay(int hght, std::ostream& ostr_lhs ) : height{hght}, ostr{ostr_lhs}, current_level{0} {} 
    levelOrderDisplay(const levelOrderDisplay&);
    levelOrderDisplay(levelOrderDisplay&&) = delete;

    virtual ~levelOrderDisplay() = default;  
    virtual void initializeTraverse() noexcept;

    // template method, which invokes display methods below.
    template<class Key, class Value> void operator()(const std::pair<Key, Value>& pr, int level) noexcept;
    //--void operator()(const typename  Tree::node_type* pnode, int level) noexcept;

    virtual void display_level(std::ostream& ostr,  int level) noexcept;
};


inline levelOrderDisplay::levelOrderDisplay(const levelOrderDisplay& lhs) : ostr{lhs.ostr}, height{lhs.height}
{
  current_level = 0;
}

template<class Key, class Value> 
void levelOrderDisplay::operator()(const std::pair<Key, Value>& pr, int level) noexcept
{
   // Did current_level change?
   if (current_level != level) { 

       current_level = level;

       display_level(ostr, level);       
   }
   
   ostr << "[ " << pr.first << ", " << pr.second << " ]" << std::flush; 
}


// Default implementation that derived class can use if they so desire to display current level of the tree that will next be displayed.
void levelOrderDisplay::display_level(std::ostream& ostr, int level) noexcept
{
  ostr << "\n\n" << "current_level = " <<  current_level; 
     
  // Provide some basic spacing to tree appearance.
  std::size_t num = height - current_level + 1;
  
  std::string str( num, ' ');
  
  ostr << str; 
}

#endif
