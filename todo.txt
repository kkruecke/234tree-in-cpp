Bug Found during removal of item 23:

During removal of item 23, when the root of [51] is converted from a 2-node, the tree loses several nodes. It had 16 items before the conversion. After it has only
eight. Q: Should converting the root be skipped except when the item to be removed is in it? What did the prior code do--as it worked removing all items.

Idea: Skip converting the root if it is a 2-node. We won't fail to search the root node as we descend. We only convert 2-nodes encountered below the root.
Read the links below to get understand deletion and examine the deletion examples comparing them with my current remove implementation.

 Or.. add back the " } else if (current != root.get() && current->isTwoNode()) {", but handle the special case when fuseWithChildren() fuses the root with its 
children. Currently, fuseWithChildren() is not even called. So we will also have to add back the code that checks whether the parent is a 2-node (which only happens
if it is the root) and calls fuseWithChildren(). This is the code that needs to be added back into convertTwoNode():

   // snip. . .
   } else { // sibling is to the left.

        sibling_index = left_adjacent; 
   }
   // Determine, based on whether the parent is a two node, whether to rotate or fuse. 
   // Check if its parent 2-node (or 3- or 4-node).
   bool parentIsTwoNode = parent->isTwoNode();

   if (has3or4NodeSibling == false) { // All adjacent siblings are also 2-nodes...

         if (parentIsTwoNode) { //... as is the parent, which must be root; otherwise, it would have already been converted.

	     convertedNode = parent->fuseWithChildren();

        } else { // parent is 3- or 4-node and there a no 3- or 4-node adjacent siblings 

             convertedNode = fuseSiblings(parent, node2_index, sibling_index);
        }

   } else { // it has a 3- or 4-node sibling.

        convertedNode = doRotation(parent, node2_index, sibling_index);
   }
   


Sources
=======

  Implementation links:

1.  http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf

This link has an excellent working example. The explanation is thorough and clear. It gives several example of deleting elements. It uses the in-order predecessor
rather than the successor when deleting.

2.  www.serc.iisc.ernet.in/~viren/Courses/2009/SE286/2-3Trees-Mod.ppt  

This link has a excellent working example and discusses how delete works, using descent restructuring. It uses the swap-with-successor for deletion of internal keys.
It contains a working tree example. It shows that when converting 2-nodes, we first check if we can rotation else we do a merge (since both siblings are 2-nodes).

3.  http://www.cs.toronto.edu/~krueger/cscB63h/lectures/tut04.txt 

This link has excellent pseudo code for both insertion and deletion with working example. But it does not restructure the key on the way down instead from the
leaf upward.

4. http://web.njit.edu/~wl256/download/cs610/n1561011.pdf

This link has a more high level pseudo code. 

5. http://www2.thu.edu.tw/~emtools/Adv.%20Data%20Structure/2-3,2-3-4%26red-blackTree_952.pdf 

This link discusses both 2 3 trees and 2 3 4 trees. It has examples and pseudo code, but the deletion logic points out that the root only can be a two node--I think?

6.  http://www.unf.edu/~broggio/cop3540/Chapter%2010%20-%202-3-4%20Trees%20-%20Part%201.ppt

This link has actual **Java implementation code** for insertion and for 2 3 4 tree interface and node interface, including members.

