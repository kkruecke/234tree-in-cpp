Bug
===

Prospective memory leak
-----------------------

The remove() code only calls unique_ptr<Node>::reset() in the case of the root. It should be calling reset() when the leaf node of the in order successor no longer has
any elements, too. The remove pseudo code (skipping the conversion of two nodes):

  1. "swap" in order successor with element to be deleted. To do this, we simply overright the element to be deleted with the in order successor and then...
  2. remove the in order successor value from the leaf node.
  3. We need to check if after the removal, the leaf node's totalItems() == 0.   

However, this will mean rewriting some of the remove() helper methods (and calls to them) so that a unique_ptr<Node234>& ultimately gets returned instead of
"Node234 *". I want to keep the raw Node234 *parent pointer if I can. unique_ptr<Node24>* seems gross.

1. rotateRight() and rotateLeft() don't return parent link ever.
2. While fuseSiblings() current returns a raw pointer. It doesn't look hard to change.
3. Only fuseWithChildren() returns the parent pointer, but it is also called with the parent pointer: parent->fuseWithChildren(....)
Maybe this can be fixed by simplying saving a prior_node that is a unique_ptr<Node234>&? Maybe the parent pointer can be
eleiminated? fuseWithSiblings() seems to be the only method that most depends upon the parent.

Do I use unique_ptr<Node234> *parent? Like this:

class X {
 private:
  std::unique_ptr<X> left;
  std::unique_ptr<X> right;

  int i;
 public:

    std::unique_ptr<X>* parent;
    X(int i);
};

X::X(int x) : i{x}, left{nullptr}, right{nullptr}, parent{nullptr}
{
}

Answer: Read up on the issue of passing unique_ptr<XYZ> reference:

1. http://stackoverflow.com/questions/11277249/how-to-pass-stdunique-ptr-around
2. http://timoch.com/blog/2013/04/std-unique_ptr-semantic
3. https://msdn.microsoft.com/library/hh279676%28v=vs.110%29.aspx
4. http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/


unique_ptr<X> f(int i)
{
    if (i == 0) {
        
        return nullptr;
    } else {
        
        return make_unique<X>(10);
    }
    
}

int main(int argc, char** argv)
{
    unique_ptr<X> p = make_unique<X>(3);
    
    p = f(10); // Since f(10) is an rvalue. Nothing is gained by doing: p = move(f(10));
    
    p = f(0);

    unique_ptr<X> p2 = make_unique<X>(2);

    p2->parent = &p;



Another issue
-------------

1. Tree234<K>::size() does not seem to be working correctly.
2. Make a manipulator to do

ostream << level_order(tree) << in_order(tree) << post_order(tree) ... etc.

Sources
=======

  Implementation links:

1.  http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf

This link has an excellent working example. The explanation is thorough and clear. It gives several example of deleting elements. It uses the in-order predecessor
rather than the successor when deleting.

2.  www.serc.iisc.ernet.in/~viren/Courses/2009/SE286/2-3Trees-Mod.ppt  

This link has a excellent working example and discusses how delete works, using descent restructuring. It uses the swap-with-successor for deletion of internal keys.
It contains a working tree example. It shows that when converting 2-nodes, we first check if we can rotation else we do a merge (since both siblings are 2-nodes).

3.  http://www.cs.toronto.edu/~krueger/cscB63h/lectures/tut04.txt 

This link has excellent pseudo code for both insertion and deletion with working example. But it does not restructure the key on the way down instead from the
leaf upward.

4. http://web.njit.edu/~wl256/download/cs610/n1561011.pdf

This link has a more high level pseudo code. 

5. http://www2.thu.edu.tw/~emtools/Adv.%20Data%20Structure/2-3,2-3-4%26red-blackTree_952.pdf 

This link discusses both 2 3 trees and 2 3 4 trees. It has examples and pseudo code, but the deletion logic points out that the root only can be a two node--I think?

6.  http://www.unf.edu/~broggio/cop3540/Chapter%2010%20-%202-3-4%20Trees%20-%20Part%201.ppt

This link has actual **Java implementation code** for insertion and for 2 3 4 tree interface and node interface, including members.

