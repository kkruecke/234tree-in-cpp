Implementation links:

  2 3 4 implementation discussions and pseudo code links:

This link has an excellent working example. The explanation is thorough and clear. It gives several example of deleting elements. It uses the in-order predecessor
rather than the successor when deleting.

  http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf

This link has a excellent working example and discusses how delete works, using descent restructuring. It uses the swap-with-successor for deletion of internal keys.
It contains a working tree example. It shows that when converting 2-nodes, we first check if we can rotation else we do a merge (since both siblings are 2-nodes).

  www.serc.iisc.ernet.in/~viren/Courses/2009/SE286/2-3Trees-Mod.ppt  

This link has excellent pseudo code for both insertion and deletion with working example. But it does not restructure the key on the way down instead from the
leaf upward.

  http://www.cs.toronto.edu/~krueger/cscB63h/lectures/tut04.txt 

This link has a more high level pseudo code. 

  http://web.njit.edu/~wl256/download/cs610/n1561011.pdf

This link discusses both 2 3 trees and 2 3 4 trees. It has examples and pseudo code, but the deletion logic points out that the root only can be a two node--I think?

  http://www2.thu.edu.tw/~emtools/Adv.%20Data%20Structure/2-3,2-3-4%26red-blackTree_952.pdf 

This link has actual **Java implementation code** for insertion and for 2 3 4 tree interface and node interface, including members.

  http://www.unf.edu/~broggio/cop3540/Chapter%2010%20-%202-3-4%20Trees%20-%20Part%201.ppt


TODOES/Thoughts
===============

1. Q: Are doRotation() and fuseSiblings() identical code? 
   A: Work from high level pseudo code and working example here http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf. Also consult the working pseudo code and
   example here http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf--but change the example to use an in-order successor rather than predecessor.

2. Q: Do I need to add or delete move ctor and move assignment to Node234 class? 
   A: No, the don't handle any resources. 

2. The code for

 template<typename K> bool Tree234<K>::remove(K key, Node234 *current)

code looks messy and confused, especially looking for the inorder successor. It relies on a check_if_key_moved flag to track whether the index of the in-order
successor has moved due to side effects of calling other member functions. This makes the code awfully messy. And it uses a prospective_in_order successor pointer
in a complex loop, again making it hard to read.


3. Should I consider a tree descend_iterator class to use in the implementation, and use it, say, for searching for a hit, etc?

 Usage:

DesentSearchIterator finder(root);

do { 

  if (finder->found())
         break; 
      
} while (finder->next() != nullptr && !finder->eof());

Any need for it?    
