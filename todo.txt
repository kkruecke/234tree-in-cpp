TODO
====

The reverse_iterator prints the last element twice when used in a loop like this:

    template<class Key, class Value> void rprint(const tree234<Key, Value>& tree, ostream& ostr)
    {
       // This has a  bug. 
       auto end = tree.rend();
    
       for(auto iter = tree.rbegin(); iter != end; ++iter) {
     
          auto& pr = *iter;
    
          ostr << pr.first << ", " << flush;
       }
       
       ostr << endl;
    }

However this loop works fine

    template<class Key, class Value> void rprint(const tree234<Key, Value>& tree, ostream& ostr)
    {
       // This works
       typename tree234<Key, Value>::const_iterator start{tree,  tree234<Key, Value>::iterator_position::end};
    
       typename tree234<Key, Value>::const_iterator finish(tree, tree234<Key, Value>::iterator_position::beg);
     
       while( start != finish) {
     
          auto& pr = *start;
    
          ostr << pr.first << ", " << flush;
               
          --start;
       }
       
       ostr << endl;
    }
    
getPredecessor() seems to work ok, so I'm not sure where the bug is.

insert
------

Tailor the insert test cases in main.cpp so that when insert calls split (to split a 3-node), when test both when the parent is a 2-node and a 3-node, and we ensure that when split inserts the middle value (of the 3-node) into the parent,
the value will be inserted in every possible position in the parent--before the first key, after the first, or (in the case of 3-nodes) before the second key or after it.

remove
------

remove()'s output needs to be examined to confirm that it is a valid 2-3-4 tree, after an element is removed. 
