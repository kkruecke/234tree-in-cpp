Draw the tree out and follow it step by step, using DebugPrinter and DepthTracker output.

The new convertTwoNode(Node234*) code in tree234.h, comparing its output to that the original code, is orphaning nodes because some values
that should still be in the tree (and to be removed).

Comparing the before and after DebugPrinter output, shows all these tree values are missing after the removal of the first item 60:

Two node:   address(0x74dea0): key[0] = 92: parent[0x74df20]->children[2]->keys[0] = 92 <-- is Leaf 

Four node:  address(0x74df20): key[1] = 90: parent[ root ]->children[1]->keys[1] = 90

Three node: address(0x74e060): key[0] = 100: parent[0x74df20]->children[3]->keys[0] = 100 <-- is Leaf 

Three node: address(0x74e060): key[1] = 201: parent[0x74df20]->children[3]->keys[1] = 201 <-- is Leaf 

Four node:  address(0x74df20): key[2] = 97: parent[ root ]->children[1]->keys[2] = 97

Two node:   address(0x74e020): key[0] = 23: {Root}

TODOES/Thoughts
===============

1. Q: Are doRotation() and fuseSiblings() identical code? 

A: Work from high level pseudo code and working example here http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf. Also consult the working pseudo code and
example here http://www.cs.ubc.ca/~liorma/cpsc320/files/B-trees.pdf--but change the example to use an in-order successor rather than predecessor.

2. Q: Do I need to add or delete move ctor and move assignment to Node234 class? 
   A: No, the don't handle any resources. 

2. The code for

 template<typename K> bool Tree234<K>::remove(K key, Node234 *current)

code looks messy and confused, especially looking for the inorder successor. It relies on a check_if_key_moved flag to track whether the index of the in-order
successor has moved due to side effects of calling other member functions. This makes the code awfully messy. And it uses a prospective_in_order successor pointer
in a complex loop, again making it hard to read.


3. Should I consider a tree descend_iterator class to use in the implementation, and use it, say, for searching for a hit, etc?

 Usage:

DesentSearchIterator finder(root);

do { 

  if (finder->found())
         break; 
      
} while (finder->next() != nullptr && !finder->eof());

Any need for it?    
